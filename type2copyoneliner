Start-Sleep -Seconds 5; Add-Type -AssemblyName 'System.Windows.Forms'; '<text_to_copy_here>' | ForEach-Object { [System.Windows.Forms.SendKeys]::SendWait($_.ToString()); Start-Sleep -Milliseconds 100 }


Start-Sleep -Seconds 5; Add-Type -AssemblyName 'System.Windows.Forms' -ErrorAction Stop; 'This is a test' | ForEach-Object { [System.Windows.Forms.SendKeys]::SendWait($_.ToString()); Start-Sleep -Milliseconds 100 }


Start-Sleep -Seconds 5; $text = 'This is a test'; $text.ToCharArray() | ForEach-Object { Write-Host -NoNewline $_; Start-Sleep -Milliseconds 100 }


## Using VBS
powershell -ExecutionPolicy Bypass -Command "Start-Sleep -Seconds 5; $text = 'This is a test'; $vbScript = \"$wshell = CreateObject('WScript.Shell'); WScript.Sleep 1000; $wshell.SendKeys('$text')\"; $vbScript | Set-Content -Path \"$env:TEMP\temp.vbs\"; cscript //nologo \"$env:TEMP\temp.vbs\"; Remove-Item \"$env:TEMP\temp.vbs\""



##script run with script.ps1 "text to test"

param (
    [string]$text
)

# Wait for 5 seconds
Start-Sleep -Seconds 5

# Create a VBScript that sends the keystrokes
$vbScriptPath = "$env:TEMP\sendkeys.vbs"
$vbScriptContent = @"
Set WshShell = CreateObject("WScript.Shell")
WScript.Sleep 1000
WshShell.SendKeys "$text"
"@

# Write the VBScript to a file
$vbScriptContent | Set-Content -Path $vbScriptPath

# Run the VBScript
cscript //nologo $vbScriptPath

# Clean up the VBScript
Remove-Item $vbScriptPath







####### using Add-Type

param (
    [string]$text
)

# Wait for 5 seconds
Start-Sleep -Seconds 5

# Load the necessary assembly if it's not already loaded
if (-not [System.Windows.Forms.SendKeys]) {
    Add-Type -AssemblyName System.Windows.Forms
}

# Send the keystrokes
foreach ($char in $text.ToCharArray()) {
    [System.Windows.Forms.SendKeys]::SendWait($char)
    Start-Sleep -Milliseconds 100 # Optional delay for typing speed
}




